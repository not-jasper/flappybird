<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>Flappy Bird - Cheats Edition</title>
  <style>
    * {margin:0;padding:0;box-sizing:border-box;user-select:none;-webkit-tap-highlight-color:transparent}
    html,body {overflow:hidden;width:100vw;height:100vh;background:#70c5ce}
    canvas {display:block;width:100vw;height:100vh;image-rendering:pixelated}
    #flash, #fade {
      position:absolute;top:0;left:0;width:100vw;height:100vh;pointer-events:none
    }
    #flash {background:white;opacity:0;transition:opacity 0.5s ease-out;}
    #fade {background:black;opacity:0;transition:opacity 0.5s ease-in-out;}
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <div id="flash"></div>
  <div id="fade"></div>
  <script>
    const canvas = document.getElementById('game'), ctx = canvas.getContext('2d');
    const flash = document.getElementById('flash'), fade = document.getElementById('fade');
    let VIRTUAL_WIDTH = window.innerWidth, VIRTUAL_HEIGHT = window.innerHeight;
    canvas.width = VIRTUAL_WIDTH;
    canvas.height = VIRTUAL_HEIGHT;

    const CONFIG = {
      gravity: 0.0005625 * VIRTUAL_HEIGHT,
      lift: -0.010625 * VIRTUAL_HEIGHT,
      scrollSpeed: 0.009 * VIRTUAL_WIDTH,
      groundSpeed: 0.009 * VIRTUAL_WIDTH,
      bgSpeed: 0.0015 * VIRTUAL_WIDTH,
      birdX: VIRTUAL_WIDTH / 4,
      pipeGap: VIRTUAL_HEIGHT * 0.18,
      pipeSpacing: VIRTUAL_WIDTH * 0.75,
      pipeOffsetY: -VIRTUAL_HEIGHT * 0.35,
      scoreScale: 1,
      scorePerPipe: 1,
      isDaytime: true,
      randomTime: false,
      pipeRandomness: VIRTUAL_HEIGHT * 0.4,
      holdToFly: false,
      godMode: false,
      noClip: false
    };

    Object.defineProperty(window, 'gameConfig', {
      get: () => CONFIG
    });

    const sounds = {
      flap: new Audio('sfx/flap.mp3'),
      hit: new Audio('sfx/hit.mp3'),
      die: new Audio('sfx/die.mp3'),
      score: new Audio('sfx/score.mp3'),
      start: new Audio('sfx/start.mp3')
    };
    for (let key in sounds) {
      sounds[key].load();
      sounds[key].preload = 'auto';
    }

    const loadImage = src => { const img = new Image(); img.src = src; return img; };

    let bgDay = loadImage('img/bg_day.png'), bgNight = loadImage('img/bg_night.png'), bgImg;
    let groundImg = loadImage('img/ground.png'), pipeTop = loadImage('img/toppipe.png'), pipeBot = loadImage('img/botpipe.png');
    let getReady = loadImage('img/getready.png'), gameOver = loadImage('img/go.png');
    let tap = [loadImage('img/tap/t0.png'), loadImage('img/tap/t1.png')];
    let birdFrames = [loadImage('img/bird/b0.png'), loadImage('img/bird/b1.png'), loadImage('img/bird/b2.png')];
    let numbers = Array.from({length:10},(_,i)=>loadImage(`img/numbers/${i}.png`));

    let frame = 0, gameStarted = false, gameOverState = false;
    let birdY = VIRTUAL_HEIGHT / 2, birdV = 0, angle = 0;
    let pipes = [], groundX = 0, bgX = 0, score = 0;
    let fading = false, mouseHeld = false;

    function resetGame() {
      birdY = VIRTUAL_HEIGHT / 2; birdV = 0; pipes = []; groundX = 0; bgX = 0; angle = 0;
      gameStarted = false; gameOverState = false; score = 0;
      bgImg = CONFIG.randomTime ? (Math.random() < 0.5 ? bgDay : bgNight) : (CONFIG.isDaytime ? bgDay : bgNight);
      fade.style.opacity = 0;
      fading = false;
    }

    function boxCollides(a, b) {
      return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h > b.y;
    }

    function update() {
      frame++;
      drawBackground();
      if (gameStarted) drawPipes();

      if (!gameOverState) {
        if (gameStarted) {
          if (CONFIG.holdToFly && mouseHeld) birdV = CONFIG.lift;
          else birdV += CONFIG.gravity;
          birdY += birdV;
          angle = Math.min(Math.PI / 4, birdV * 0.12);
        } else {
          birdV = 0;
          angle = 0;
        }
      } else {
        birdV += CONFIG.gravity;
        birdY += birdV;
      }

      if (gameStarted && !gameOverState && !CONFIG.godMode && !CONFIG.noClip) {
        const birdBox = {
          x: CONFIG.birdX - 16 * VIRTUAL_HEIGHT / 480,
          y: birdY - 12 * VIRTUAL_HEIGHT / 480,
          w: 32 * VIRTUAL_HEIGHT / 480,
          h: 24 * VIRTUAL_HEIGHT / 480
        };
        for (let p of pipes) {
          let pipeW = pipeTop.width * VIRTUAL_HEIGHT / 480;
          let pipeTopBox = { x: p.x, y: p.y, w: pipeW, h: pipeTop.height * VIRTUAL_HEIGHT / 480 };
          let pipeBotBox = { x: p.x, y: p.y + pipeTop.height * VIRTUAL_HEIGHT / 480 + p.gap, w: pipeW, h: pipeBot.height * VIRTUAL_HEIGHT / 480 };
          if (boxCollides(birdBox, pipeTopBox) || boxCollides(birdBox, pipeBotBox)) {
            gameOverState = true;
            sounds.hit.currentTime = 0; sounds.hit.play();
            setTimeout(() => sounds.die.play(), 100);
            flash.style.opacity = 1;
            setTimeout(() => flash.style.opacity = 0, 100);
            break;
          }
        }
      }

      if (birdY + birdFrames[0].height / 2 * VIRTUAL_HEIGHT / 480 > VIRTUAL_HEIGHT - groundImg.height * VIRTUAL_HEIGHT / 480) {
        birdY = VIRTUAL_HEIGHT - groundImg.height * VIRTUAL_HEIGHT / 480 - birdFrames[0].height / 2 * VIRTUAL_HEIGHT / 480;
        if (!gameOverState && !CONFIG.godMode) {
          gameOverState = true;
          sounds.die.currentTime = 0;
          sounds.die.play();
        }
      }

      drawGround();
      drawBird();
      drawScore();
      drawUI();
      requestAnimationFrame(update);
    }

    function handleTap() {
      if (fading) return;
      if (!gameStarted && !gameOverState) {
        gameStarted = true;
        return;
      }
      if (!gameOverState && gameStarted && !CONFIG.holdToFly) {
        birdV = CONFIG.lift;
        sounds.flap.currentTime = 0;
        sounds.flap.play();
      } else if (gameOverState) {
        fading = true;
        fade.style.opacity = 1;
        sounds.start.currentTime = 0;
        sounds.start.play();
        setTimeout(resetGame, 500);
      }
    }

    canvas.addEventListener('mousedown', () => mouseHeld = true);
    canvas.addEventListener('mouseup', () => mouseHeld = false);
    canvas.addEventListener('touchstart', e => { mouseHeld = true; handleTap(); });
    canvas.addEventListener('touchend', () => mouseHeld = false);
    window.addEventListener('keydown', e => {
      if (['w', 'W', 'ArrowUp', ' '].includes(e.key)) handleTap();
    });

    resetGame();
    update();
  </script>
</body>
</html>
